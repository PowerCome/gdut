# Git

## 理论

### 三棵树

工作区（工作目录）--暂存区（INDEX，临时保存你的改动）--HEAD区（指向你最后提交的结果)（本地库）

### 哈希
#### 特点：
有不同算法
算法确定，则长度确定
同个文件同个算法内容不变的话的加密结果相同
哈希底层用sha-1算法
#### 应用
校验文件是否丢失数据：原始文件与目标文件不一样，算法加密后结果就不一样
### Git保存版本机制
#### 与集中式的不同
集中式版本控制系统：保存变化部分的文件，最终将所有增加的以及原始组合成一个版本
（分布式）git：快照流
每次commit，git为当前所有文件制作一个快照并保存该快照的索引
当文件没有任何修改时，git不会重新储存该文件，只是保留一个指针，指向之前的存储的文件
#### 管理机制细节
每次提交commit，产生一个”提交对象“，每个快照有一个提交对象

![1553320239235](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553320239235.png)

版本之间的联系由链条形成

![1553320447553](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553320510057.png)

#### 分支管理机制

![1553321132430](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553321132430.png)


##  基本操作git 

### 添加和提交

**先在命令窗口用   cd 路径 进入你要创建本地库文件夹的地方**

新建本地库：
mkdir 本地库名称（将会在当前目录下生成同名的文件夹）
git init

```
git add 文件名 //添加到暂存区
git commit -m "代码提交信息"  //方便以后查看文件的修改，此时已经将文件交到HEAD
```



### 查看操作

#### git status：查看状态
#### ll：查看工作区有几个文件
#### cat 文件名：查看文件内容
#### 查看历史记录

**注意：以下几个操作显示的记录都只显示HEAD以及之前的记录，HEAD之后的不显示(除了git reflog)**

git log

查看完整的记录

##### git log --pretty=oneline

一行显示一个记录

![1553271573202](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553271573202.png)

##### git log --oneline

只给出哈希值的前几位，简化输出

![1553271592798](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553271592798.png)

##### git reflog

简化哈希值，同时HEAD@{移动到当前版本需要的步数}

![1553271603680](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553271603680.png)

### 前进后退

#### reset命令的三个参数

--soft：只移动HEAD指针，突出缓存区

--ｍixed（默认）:本地库移动指针，重置缓存区，突出本地库

--hard（常用）：本地库移动指针，重置缓存区、工作区

#### --hard操作

#####  基于索引值（推荐）

git reset --hard  局部索引值

配合git reflog，HEAD此时指向索引值对应的记录,就能查看当前记录的文本

使用git reset --hard HEAD可以直接让HEAD重新指向最新的记录上

![1553273390444](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553273390444.png)

##### ^符号

一个^表示往回退一步  *不可往前*

##### ~符号

表示回退n步：git reset --hard HEAD~n;



### 删除文件后找回
前提：文件已经提交到本地库后才删除的
rm 文件名：将文件从本地库删除
```
//记录文件的删除（可以不记）
rm 文件名
git add 文件名  
git commit -m "delete 文件名"
git reflog //找到当初commit文件时的哈希值索引
git reset --hard 索引  //回退到提交文件的状态，此时文件找回
```
### 文件对比
#### git diff 文件名
指定比较的文件，将工作区的该文件与暂存区的该文件进行比较
#### git diff[本地库历史版本] 文件名
指定比较的文件，将工作区的该文件与本地库某个版本的该文件比较
#### git diff 
不指定需要比较的文件名，即比较所有工作区和暂存区同个的文件（有差异就会显示）
#### git diff 本地库历史版本
不指定需要比较的文件，对比所有工作区和它在本地库的文件（此时可以比较指定的本地库文件的版本号）
比较本地库当前版本的话，命为 git diff HEAD
### 分支
#### 好处
允许多个进程推进
#### 分支操作
##### 创建分支
git branch [分支名]
##### 查看分支
git branch -v
##### 切换分支
git checkout [分支名]
##### 合并分支
切换到接受修改的（主分支）：git checkout  分支名
执行merge命令：git merge  有新内容的分支名
#### 解决冲突
##### 冲突的表现

当两个合并的分支同个位置的内容一样，就会产生冲突

![1553317067453](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553317067453.png)

##### 冲突的解决
第一:编辑文件，删除特殊符号（即上图中“<<<""===="">>>")，把文件修改到自己要的程度，保存退出
第二：git add （发生冲突的）文件名
第三：git commit -m ”日志信息“
**此时commit后不能带文件名**

##  本地库与远程库

### 交互

### ![1553322341056](C:\Users\至此终年\AppData\Roaming\Typora\typora-user-images\1553322341056.png)
### 创建远程库
最好与本地库同名
使用以下指令为远程库地址起别名，方便访问
```
git remote add 别名 远程库地址
```
使用git remote -v查看已有的远程库
### 推送分支到远程库
git push  别名 推送的分支的名称
### 与队友共同管理远程库
####  克隆远程库
##### 命令
git colne 远程库地址
在克隆前先创立自己的本地库，执行mkdir 名称即可
##### 效果
完整把远程库下载到本地（把远程库所有内容放在本地库中）
创建远程地址别名（此时本地库也可用以用别名对远程库进行操作，无需重新起别名）
初始化本地库（生成.git文件，故创建本地库时无需git init）
#### 与队友组队
邀请队友：官网--settings--左侧Collaborators--中间输入队友Github账号--复制邀请链接并发给好友
接受邀请：复制链接--官网打开--accept
**成为队友后，就可以把自己对克隆修改后的分支push到远程库**
#### 把远程库的文件获取到本地库（pull）
pull=fetch +merge
第一，git fetch 远程库别名 要获取的远程库分支名（此时从远程库分支下载文件到本地库，但没有到自己的工作区）
第二，转换到远程库分支        git checkout 远程别名/远程库分支名称
第三，用cat查看分支中的文件有没有问题 
第四，git merge  远程别名/远程库分支名称   这样就把远程库分支上的文件拉到本地库中了

















]
